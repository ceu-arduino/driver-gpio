#ifndef GPIO__SAMD_CEU
#define GPIO__SAMD_CEU

#include "../gpio.ceu"

// Copied from "cores/arduino/WInterrupts.c"

{
    NVIC_DisableIRQ(EIC_IRQn);
    NVIC_ClearPendingIRQ(EIC_IRQn);
    NVIC_SetPriority(EIC_IRQn, 0);
    NVIC_EnableIRQ(EIC_IRQn);

    // Enable GCLK for IEC (External Interrupt Controller)
    GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_ID(GCM_EIC));

    /* Shall we do that?
    // Do a software reset on EIC
    EIC->CTRL.SWRST.bit = 1 ;
    while ((EIC->CTRL.SWRST.bit == 1) && (EIC->STATUS.SYNCBUSY.bit == 1)) { }
    */

    // Enable EIC
    EIC->CTRL.bit.ENABLE = 1;
    CEU_SAMD_WAIT(*EIC);
}

native/const _EIC_Handler;
spawn async/isr [_EIC_Handler] do
#ifdef GPIO_SAMD_PIN_02
    if {EIC->INTFLAG.reg & GPIO_SAMD_PIN_02_MASK} != 0 then
        var high/low v = _digitalRead(2);
        emit PIN_IN(2, v);
        emit PIN_02(v);
        { EIC->INTFLAG.reg = GPIO_SAMD_PIN_02_MASK; } // Clear the interrupt
    end
#endif
#ifdef GPIO_SAMD_PIN_03
    if {EIC->INTFLAG.reg & GPIO_SAMD_PIN_03_MASK} != 0 then
        var high/low v = _digitalRead(3);
        emit PIN_IN(3, v);
        emit PIN_03(v);
        { EIC->INTFLAG.reg = GPIO_SAMD_PIN_03_MASK; } // Clear the interrupt
    end
#endif
#ifdef GPIO_SAMD_PIN_05
    if {EIC->INTFLAG.reg & GPIO_SAMD_PIN_05_MASK} != 0 then
        var high/low v = _digitalRead(5);
        emit PIN_IN(5, v);
        emit PIN_05(v);
        { EIC->INTFLAG.reg = GPIO_SAMD_PIN_05_MASK; } // Clear the interrupt
    end
#endif
end

#endif
